
export const solvers: Record<string, Function> = {
    'big-o-time-complexity-conceptual': () => `Time Complexity describes how runtime grows with input size (n).\n- O(1) Constant: Accessing an array element \`arr[5]\`.\n- O(n) Linear: Looping through an array.\n- O(n²) Quadratic: A nested loop over the same array.`,
    'big-o-space-complexity-conceptual': () => `Space Complexity describes how memory usage grows with input size (n).\n- O(1) Constant: An algorithm using a fixed number of variables.\n- O(n) Linear: An algorithm creating a new array of the same size as the input.`,
    'unit-test-jest-conceptual': () => `// sum.js\nconst sum = (a, b) => a + b;\nmodule.exports = sum;\n\n// sum.test.js\nconst sum = require('./sum');\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3);\n});`,
    'test-driven-development-conceptual': () => `The TDD cycle is:\n1. Red: Write a failing test for a new feature.\n2. Green: Write the minimum code required to make the test pass.\n3. Refactor: Clean up and improve the code while keeping the test green.`,
    'jest-matchers-conceptual': () => `Matchers test values with \`expect()\`. Common matchers include:\n- .toBe(): For strict equality (===).\n- .toEqual(): For deep equality of objects/arrays.\n- .toBeTruthy(): Checks if a value is truthy.`,
    'jest-mocking-conceptual': () => `Mocking isolates a unit from its dependencies (e.g., an API call). \`jest.fn()\` creates a mock function to track calls and define return values without executing the original dependency.`,
    'performance-now': () => {
        const start = performance.now();
        // Simulate work
        for (let i = 0; i < 1000000; i++) {}
        const end = performance.now();
        return `Operation took ${(end - start).toFixed(4)} milliseconds.`;
    },
    'console-time': () => `(Conceptual) Place \`console.time('myLabel')\` before your code and \`console.timeEnd('myLabel')\` after. The browser will log the elapsed time for that label.`,
    'memoization-performance': () => `A higher-order function wraps an expensive, pure function. It uses a closure to store a cache. When called, it first checks if the result for the given arguments exists in the cache. If so, it returns the cached result; otherwise, it computes, stores, and then returns the result.`,
    'tree-shaking-performance': () => `A bundler analyzes static \`import\`/\`export\` statements. If you import \`{ add }\` from a large math library but not \`subtract\`, the bundler can safely remove the unused \`subtract\` function from the final production bundle, making the file smaller.`,
    'code-splitting-performance': () => `A technique where a bundler splits code into smaller chunks. The main chunk is loaded initially, and other chunks (e.g., for a specific route) are "lazy-loaded" on demand using dynamic \`import()\`, improving initial page load speed.`,
    'browser-profiling-conceptual': () => `The 'Performance' tab in browser dev tools lets you record a profile of your code execution. It generates a "flame chart" that visually represents the call stack over time, helping you identify which functions are taking the most time ("bottlenecks").`,
    'memory-leaks-debugging-conceptual': () => `A memory leak occurs when memory is no longer needed but not released. Common causes: detached DOM nodes held in JS variables, uncleared intervals. Use the 'Memory' tab in dev tools to take heap snapshots to find leaked objects.`,
    'debouncing-performance': () => `A technique to ensure a function only runs after a period of inactivity. Useful for search bars: instead of firing an API call on every keystroke, you wait until the user stops typing for 300ms.`,
    'throttling-performance': () => `A technique to ensure a function runs at most once per specified interval. Useful for scroll events: you might handle the scroll event, but only execute the logic at most once every 200ms to prevent performance issues.`,
    'performance-observer-conceptual': () => `An API to observe performance measurement events. You create an observer: \`new PerformanceObserver(list => ...)\` and tell it what to observe: \`observer.observe({ entryTypes: ['measure', 'paint'] })\`. It's a way to collect performance data programmatically.`,
    'web-vitals-conceptual': () => `Core Web Vitals are user-centric performance metrics:\nLCP (Largest Contentful Paint): Loading performance.\nINP (Interaction to Next Paint): Interactivity (replaces FID).\nCLS (Cumulative Layout Shift): Visual stability.`,
    'integration-testing-conceptual': () => `Integration tests check how multiple units (e.g., components, modules) work together. For example, testing that clicking a button in a 'Login' component correctly updates the state in a 'UserStore'.`,
    'e2e-testing-conceptual': () => `End-to-End testing simulates a full user workflow. A tool like Cypress or Playwright automates a browser to perform actions like: visit the page, fill out a login form, click submit, and verify that the dashboard page is displayed.`,
    'critical-rendering-path-conceptual': () => `The sequence of steps the browser takes to render a page: constructing the DOM and CSSOM trees, combining them into a Render Tree, performing Layout, and Painting. Optimizing this path is key to fast perceived performance.`,
    'big-o-logarithmic-time': () => `O(log n) means time complexity grows logarithmically. The problem size is halved at each step. Example: Binary search on a sorted array of 1,000,000 items takes at most 20 comparisons, not 1,000,000.`,
    'big-o-log-linear-time': () => `O(n log n) is a very efficient time for sorting. It's faster than O(n²). Efficient sorting algorithms like Merge Sort and Heap Sort have this complexity. Sorting 1,000,000 items is much faster than a nested loop over them.`,
    'jest-async-testing': () => `For promises, return the promise and chain \`.resolves\` or \`.rejects\`. For async/await: \`test('...", async () => { await expect(myAsyncFunc()).resolves.toBe(value); });\``,
    'jest-setup-teardown': () => `\`beforeEach(() => { /* runs before every test */ });\`\n\`afterEach(() => { /* runs after every test */ });\`\n\`beforeAll()\` and \`afterAll()\` run once for the entire file.`,
    'jest-spies': () => `\`const spy = jest.spyOn(console, 'log'); myFunc(); expect(spy).toHaveBeenCalled();\`. This tracks calls to \`console.log\` without replacing its implementation.`,
    'snapshot-testing': () => `The first time a test with \`expect(component).toMatchSnapshot();\` runs, Jest creates a snapshot file. On subsequent runs, the new output is compared to the stored snapshot. If they don't match, the test fails, alerting you to unintended UI changes.`,
    'image-optimization-conceptual': () => `Strategies:\n1. Compression: Reduce file size with tools like ImageOptim.\n2. Modern Formats: Use WebP or AVIF for better compression than JPG/PNG.\n3. Lazy Loading: Only load images when they are about to scroll into the viewport.`,
    'caching-strategies-conceptual': () => `1. Browser Cache: Use HTTP headers like \`Cache-Control\`.\n2. CDN (Content Delivery Network): Caches assets at edge locations closer to users.\n3. Service Worker: Intercepts requests to serve assets from a programmatic cache, enabling offline access.`,
    'virtualization-lists-conceptual': () => `For a list with 10,000 items, virtualization (or "windowing") only renders the ~20 items currently visible in the viewport. As the user scrolls, it re-renders the window with new items, maintaining high performance.`,
    'bundle-analysis-conceptual': () => `A tool like \`webpack-bundle-analyzer\` generates an interactive treemap of your final JS bundle. This helps you visually identify large dependencies or duplicated code that could be removed or code-split to reduce the bundle size.`,
    'first-contentful-paint': () => `FCP measures the time from when the page starts loading to when any part of the page's content is rendered on the screen. This could be text, an image, or a canvas. It's a key "perceived load speed" metric.`,
    'time-to-first-byte': () => `TTFB measures the time from the user initiating the request (e.g., clicking a link) to the first byte of the HTML document being received. A high TTFB indicates a slow server response or network latency.`,
    'time-to-interactive': () => `TTI measures the time from when the page starts loading to when it's both visually rendered and reliably responsive to user input. It marks the point where the page is fully usable.`,
    'load-testing-vs-stress-testing': () => `Load Testing: Simulates expected user traffic to ensure the system performs well under normal conditions.\nStress Testing: Pushes the system beyond its limits to find its breaking point and determine how it recovers from failure.`,
    'code-coverage': () => `A metric that measures what percentage of your code is executed by your tests. It helps identify untested parts of your codebase. 100% coverage doesn't guarantee your code is bug-free, but low coverage indicates a high risk of undetected bugs.`,
    'static-analysis-tools': () => `These tools analyze code without running it. ESLint finds potential bugs and enforces coding styles. Prettier automatically formats code to be consistent. They improve code quality and reduce time spent on manual code reviews.`,
    'web-worker-performance': () => `If a synchronous task (e.g., complex calculation, parsing a large file) blocks the main thread and freezes the UI, it can be moved to a Web Worker. The main thread offloads the task to the worker and receives the result via a message, keeping the UI responsive.`,
    'server-side-rendering-performance': () => `SSR sends a fully rendered HTML page from the server. The browser can display this immediately, resulting in a fast First Contentful Paint (FCP). This improves perceived load speed compared to a client-side rendered app that shows a blank page while it fetches and runs JavaScript.`,
    'cdn-performance': () => `A CDN is a global network of servers. It caches your static assets (JS, CSS, images) on servers that are geographically closer to your users. This reduces network latency and speeds up asset delivery.`,
    'database-n-plus-one-problem': () => `A common performance issue. Example: 1 query to get 100 blog posts, followed by 100 separate queries to get the author for each post (totaling 101 queries). The solution is to fetch all the required data in fewer queries, for example, by using a JOIN.`,
    'css-selectors-performance': () => `The browser evaluates CSS selectors from right to left. A selector like \`#nav a\` is fast because the rightmost part is specific. A selector like \`* > .menu-item\` is slow because the browser must first find all elements (\`*\`) and then check their parent.`,
    'layout-thrashing-conceptual': () => `A performance issue caused by mixing DOM reads (like \`offsetHeight\`) and writes (like \`style.height\`) in a loop. Each mix forces the browser to recalculate the layout. The fix is to batch all reads first, then batch all writes.`,
    'regression-testing-conceptual': () => `The process of re-running existing tests to ensure that a recent code change or bug fix has not introduced new bugs or broken existing functionality. It's a safety net for software maintenance.`,
    'visual-regression-testing-conceptual': () => `A testing technique where a tool takes screenshots of UI components and compares them pixel by pixel against a "golden" or baseline screenshot. The test fails if there are any visual differences, catching unintended UI changes.`,
    'accessibility-testing-conceptual': () => `Ensuring an application is usable by people with disabilities. Automated tools (like Axe) can catch issues like missing alt text. Manual testing (like using a screen reader or keyboard-only navigation) is also crucial.`,
    'fuzz-testing-conceptual': () => `An automated testing technique that provides invalid, unexpected, or random data as input to a program. It's primarily used to find security vulnerabilities, memory corruption bugs, or unhandled exceptions.`,
    'property-based-testing-conceptual': () => `Instead of writing a test for a specific input (e.g., \`add(2,3) === 5\`), you write a test for a property (e.g., \`add(a,b) === add(b,a)\`). The testing framework then generates hundreds of random inputs to try and falsify this property.`,
    'mutation-testing-conceptual': () => `A technique to measure the quality of your tests. A tool automatically introduces small defects ("mutants") into your code (e.g., changing \`>\` to \`<\`). If your test suite still passes, it means your tests are not effective enough to "kill" (detect) the mutant.`,
    'alpha-beta-testing-conceptual': () => `Alpha Testing: Internal testing by the company's own team before the product is released to any external users.\nBeta Testing: A release to a limited external audience (real users) to get feedback and find bugs before a full public release.`,
    'performance-budget-conceptual': () => `A set of limits for metrics that affect site performance (e.g., LCP < 2.5s, bundle size < 170KB, max number of requests). These budgets are enforced by the team to prevent performance from degrading over time.`,
};
